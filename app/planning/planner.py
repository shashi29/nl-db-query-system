"""
Planner module for planning query execution.
Coordinates the planning process for database queries.
"""
from typing import Any, Dict, List, Optional, Tuple, Union
import json
import time

from ..config.logging_config import logger
from ..utils.preprocessing import preprocess_query, check_dangerous_patterns
from .data_source_detector import data_source_detector
from .context_builder import context_builder
from .plan_validator import PlanValidator
from .schema_manager import schema_manager


class Planner:
    """
    Planner for database query execution.
    Coordinates the planning process and prepares for execution.
    """
    
    @staticmethod
    async def plan_query(query: str) -> Dict[str, Any]:
        """
        Plan the execution of a natural language query.
        
        Args:
            query: The natural language query.
            
        Returns:
            Dict[str, Any]: Query execution plan.
        """
        # Start timing the planning process
        start_time = time.time()
        
        try:
            # Preprocess the query
            processed_query = preprocess_query(query)
            
            # Check for dangerous patterns
            is_dangerous, reason = check_dangerous_patterns(processed_query)
            if is_dangerous:
                return {
                    "success": False,
                    "error": f"Query contains potentially dangerous patterns: {reason}",
                    "planning_time": time.time() - start_time
                }
            
            # Detect data source
            data_source_info = await data_source_detector.detect_data_source(processed_query)
            
            # Build context for OpenAI
            context = context_builder.build_context(data_source_info)
            
            # Prepare response
            plan = {
                "success": True,
                "original_query": query,
                "processed_query": processed_query,
                "data_source_info": data_source_info,
                "context": context,
                "planning_time": time.time() - start_time
            }
            
            logger.info(f"Query planned successfully in {time.time() - start_time:.2f}s")
            return plan
            
        except Exception as e:
            logger.error(f"Error planning query: {str(e)}")
            return {
                "success": False,
                "error": f"Error planning query: {str(e)}",
                "planning_time": time.time() - start_time
            }

    @staticmethod
    async def refine_plan(plan: Dict[str, Any], openai_response: Dict[str, Any]) -> Dict[str, Any]:
        """
        Refine a query plan based on OpenAI's response.
        
        Args:
            plan: The initial query plan.
            openai_response: The response from OpenAI.
            
        Returns:
            Dict[str, Any]: Refined query execution plan.
        """
        start_time = time.time()
        
        try:
            # Extract the query plan generated by OpenAI
            generated_plan = openai_response.get("generated_plan", {})
            
            # Validate the generated plan
            is_valid, reason = PlanValidator.validate_plan(generated_plan)
            
            if not is_valid:
                return {
                    "success": False,
                    "error": f"Invalid query plan: {reason}",
                    "original_plan": plan,
                    "generated_plan": generated_plan,
                    "refinement_time": time.time() - start_time
                }
                
            # Combine the original plan with the generated plan
            refined_plan = {**plan}
            refined_plan["execution_plan"] = generated_plan
            refined_plan["refinement_time"] = time.time() - start_time
            
            logger.info(f"Plan refined successfully in {time.time() - start_time:.2f}s")
            return refined_plan
            
        except Exception as e:
            logger.error(f"Error refining plan: {str(e)}")
            return {
                "success": False,
                "error": f"Error refining plan: {str(e)}",
                "original_plan": plan,
                "refinement_time": time.time() - start_time
            }

    @staticmethod
    async def initialize() -> bool:
        """
        Initialize the planner by initializing schema manager.
        
        Returns:
            bool: True if initialization was successful, False otherwise.
        """
        # try:
        # Initialize schema manager
        await schema_manager.initialize()
        return True
            
        # except Exception as e:
        #     logger.error(f"Error initializing planner: {str(e)}")
        #     return False


# Create global planner instance
planner = Planner()